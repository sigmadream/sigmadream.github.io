---
layout: post
title: 파이썬 코딩의 기술
author: 브렛 슬라킨 (지은이), 김형철 (옮긴이)
tags: book
---

## 1
파이썬을 잘 사용하기 위한 59가지 팁을 담고 있다. 파이썬 사용자라면 구글 플레이나 리디북스에서 구매해서 꼭 읽어보길 권한다.

----

> 새 파이썬 프로젝트를 시작한다면 파이썬 3를 사용할 것을 강력히 추천한다.

> “명명(naming): PEP 8은 언어의 부분별로 독자적인 명명 스타일을 제안한다. 이 스타일을 따르면 코드를 읽을 때 각 이름에 대응하는 타입을 구별하기 쉽다. 함수, 변수, 속성은 lowercase_underscore 형식을 따른다., 보호(protected) 인스턴스 속성은 _leading_underscore 형식을 따른다., 비공개(private) 인스턴스 속성은 __double_leading_underscore 형식을 따른다., 클래스와 예외는 CapitalizedWord 형식을 따른다., 모듈 수준 상수는 ALL_CAPS 형식을 따른다.”, “클래스의 인스턴스 메서드에서는 첫 번째 파라미터(해당 객체를 참조)의 이름을 self로 지정한다., 클래스 메서드에서는 첫 번째 파라미터(해당 클래스를 참조)의 이름을 cls로 지정한다.”

> “두 번째 이슈는 파이썬 3에서 내장 함수 open이 반환하는 파일 핸들을 사용하는 연산은 기본으로 UTF-8 인코딩을 사용한다는 점이다”

> “무조건 짧은 코드를 만들기보다는 가독성을 선택하는 편이 낫다. 이렇게 이해하기 어려운 복잡한 표현식에는 파이썬의 함축적인 문법을 사용하면 안 된다”

> “경험에 비추어 볼 때 리스트 컴프리헨션을 사용할 때는 표현식이 두 개를 넘어가면 피하는 게 좋다.”

> “첫 번째 방법은 반환 값을 두 개로 나눠서 튜플에 담는 것이다. 튜플의 첫 번째 부분은 작업이 성공했는지 실패했는지를 알려준다. 두 번째 부분은 계산된 실제 결과다.”

> “이런 오류를 줄이기에 더 좋은 두 번째 방법은 절대로 None을 반환하지 않는 것이다”

> “표현식에서 변수를 참조할 때 파이썬 인터프리터는 참조를 해결하려고 다음과 같은 순서로 스코프(scope; 유효 범위)를 탐색한다. 1. 현재 함수의 스코프, 2. (현재 스코프를 담고 있는 다른 함수 같은) 감싸고 있는 스코프, 3. 코드를 포함하고 있는 모듈의 스코프(전역 스코프라고도 함), 4. (len이나 str 같은 함수를 담고 있는) 내장 스코프”

> “이 함수를 작성하는 더 좋은 방법은 제너레이터(generator)를 사용하는 것이다. 제너레이터는 yield 표현식을 사용하는 함수다. 제너레이터 함수는 호출되면 실제로 실행하지 않고 바로 이터레이터(iterator)를 반환한다. 내장 함수 next를 호출할 때마다 이터레이터는 제너레이터가 다음 yield 표현식으로 진행하게 한다. 제너레이터에서 yield에 전달한 값을 이터레이터가 호출하는 쪽에 반환한다.”

> “파이썬에서 결과가 기대한 대로 나오게 하려면 기본값을 None으로 설정하고 docstring(문서화 문자열)으로 실제 동작을 문서화하는 게 관례다(Better way 49 “모든 함수, 클래스, 모듈에 docstring을 작성하자” 참고). 코드에서 인수 값으로 None이 나타나면 알맞은 기본값을 할당하면 된다”

> “하지만 계층이 한 단계가 넘는 중첩은 피해야 한다(즉, 딕셔너리를 담은 딕셔너리는 쓰지 말아야 한다). 여러 계층으로 중첩하면 다른 프로그래머들이 코드를 이해하기 어려워지고 유지보수의 악몽에 빠지게 된다.”

> “다음 코드에서는 튜플에 있는 세 번째 값을 _로 받아서 그냥 무시하도록 했다(파이썬에서는 관례적으로 사용하지 않을 변수에 밑줄 변수 이름을 쓴다).”

> “다른 언어에서라면 후크를 추상 클래스로 정의할 것이라고 예상할 수도 있다. 하지만 파이썬의 후크 중 상당수는 인수와 반환 값을 잘 정의해놓은 단순히 상태가 없는 함수다. 함수는 클래스보다 설명하기 쉽고 정의하기도 간단해서 후크로 쓰기에 이상적이다. 함수가 후크로 동작하는 이유는 파이썬이 일급 함수(first-class function)를 갖췄기 때문이다. 다시 말해, 언어에서 함수와 메서드를 다른 값처럼 전달하고 참조할 수 있기 때문이다.”

> “클래스가 다중 상속(보통은 피해야 할 방법이다. Better way 26 “믹스인 유틸리티 클래스에만 다중 상속을 사용하자"를 참고하기 바란다)의 영향을 받는다면 슈퍼클래스의 __init__ 메서드를 직접 호출하는 행위는 예기치 못한 동작을 일으킬 수 있다.”

> “파이썬 프로그래밍의 대부분은 데이터를 담은 클래스들을 정의하고 이 객체들이 연계되는 방법을 명시하는 일이다. 모든 파이썬 클래스는 일종의 컨테이너로, 속성과 기능을 함께 캡슐화한다. 파이썬은 데이터 관리용 내장 컨테이너 타입(리스트, 튜플, 세트, 딕셔너리)도 제공한다.”

> “파이썬의 표준 구현을 CPython이라고 한다. CPython은 파이썬 프로그램을 두 단계로 실행한다. 먼저 소스 텍스트를 바이트코드(bytecode)로 파싱하고 컴파일한다. 그런 다음 스택 기반 인터프리터로 바이트코드를 실행한다. 바이트코드 인터프리터는 파이썬 프로그램이 실행되는 동안 지속되고, 일관성 있는 상태를 유지한다. 파이썬은 전역 인터프리터 잠금(GIL, Global Interpreter Lock)이라는 메커니즘으로 일관성을 유지한다. 본질적으로 GIL은 상호 배제 잠금(mutex; 뮤텍스)이며 CPython이 선점형 멀티스레딩의 영향을 받지 않게 막아준다. 선점형 멀티스레딩(preemptive multithreading)은 한 스레드가 다른 스레드를 인터럽트(차단)해서 프로그램의 제어를 얻는 것을 말한다. 이 인터럽트가 예상치 못한 시간에 일어나면 인터프리터 상태가 망가진다. [...]”

> “파이썬은 두 가지 시간대 변환 방법을 제공한다. 내장 모듈 time을 사용하는 이전 방법은 치명적인 오류가 일어날 가능성이 크다. 내장 모듈 datetime을 사용하는 새로운 방법은 커뮤니티에서 만든 pytz 패키지의 도움을 받아 훌륭하게 동작한다. datetime이 최선의 선택이고 time을 사용하지 말아야 하는 이유를 완전히 이해할 때까지 time과 datetime을 사용하는 방법을 숙지해야 한다.”

